# 0. Overview

이펙티브 자바 **아이템11. equals를 재정의하려거든 hashCode도 재정의하라**를 보고 공부한 내용을 정리했다.

equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않는다.

재정의한 hashCode는 Object의 API문서에 기술된 일반 규약을 따라야 한다.

# 1. 일반 규약

1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hasCode 메소드를 몇 번을 호출해도
일관되게 항상 같은 값을 반환해야 한다. (애플리케이션 다시 실행되면 이 값이 달라져도 됨)
2. equals가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.
3. equals가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. (다른 값을 반환해야 해시테이블 성능이 좋아지긴 한다.)

한줄 요약 : 같은 객체이면 hashCode가 같아야되는데, hasCode가 같다고 같은 객체는 아니다. (해시테이블에서의 해시 충돌 생각하면 된다.)

hashCode 재정의를 잘못했을 때 크게 문제되는 조항은 2번이다.

[아이템 10](https://github.com/dolgodolah/TIL/blob/master/java/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%20%EC%9E%90%EB%B0%94/%EC%95%84%EC%9D%B4%ED%85%9C10.%20equals%EB%8A%94%20%EC%9D%BC%EB%B0%98%20%EA%B7%9C%EC%95%BD%EC%9D%84%20%EC%A7%80%EC%BC%9C%20%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC.md)에서 보았듯이 equals를 재정의함으로써 물리적으로 다른 두 객체를 논리적으로는 같다고 할 수 있다.

하지만 재정의하지 않은 hashCode는 두 객체를 다르다고 판단하여 서로 다른 값을 반환하게 된다.

# 2. 서로 다른 값 반환하는게 무슨 문제?

PhoneNumber 클래스의 인스턴스를 HashMap의 원소로 사용한다고 해보자.

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "제니");

String name = m.get(new PhoneNumber(707, 867, 5309));
System.out.println(name); // "제니"가 나올까?
```

위 코드를 실행하면 "제니"가 나와야 할 것 같지만, 실제로는 null을 반환한다.

hashCode를 재정의하지 않으면 논리적으로 동치인 두 객체가 서로 다른 해시코드를 반환하여 두 번째 규약을 지키지 못한다.

설사 두 인스턴스가 같은 버킷에 담겼더라도 여전히 null을 반환하는데, HashMap은 해시코드가 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않기 때문이다.

이러한 문제는 적절한 hashCode 메소드만 작성(재정의)해주면 해결된다.

# 3. hashCode 메소드 재정의

### 3.1 잘못된 방법(규약은 지키지만 최악, 사용 금지)

```java
@Override
public int hashCode() {
    return 42;
}
```

동치인 모든 객체에서 똑같은 해시코드를 반환하게 되니 적법하다.

하지만 모든 객체에게 똑같은 값만 내어주므로 해시테이블이 연결 리스트처럼 동작하게 된다. O(1) -> O(n)

즉, 서로 다른 인스턴스에 대해서는 다른 해시코드를 반환할 수록 좋은 해시 함수일 것이다.

### 3.2 전형적인 방법

```java
@Override
public int hashCode() {
    int result = Short.hashCoe(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

PhoneNumber 인스턴스의 핵심 필드 3개만을 사용해 간단한 계산을 수행한다.

동치인 PhoneNumber 인스턴스들은 같은 해시코드를 가지게 될 것이고, 서로 다른 전화번호들은 다른 해시 버킷들로 제법 훌륭히 분배될 것이다.

- 31 을 곱하는 이유 : 31은 홀수이며 소수이기 때문이다.
> 만일 이 값이 짝수면서 곱셈의 결과가 오버플로우 되었다면 해시 값이 유실되었을 것이다. 2(의 배수)를 곱한다는 것은 비트의 이동을 의미하기 때문이다. 소수를 사용했을 때 어떤 장점이 있는지는 분명하지 않지만 관례적으로 그렇게 한다. 31의 좋은 점은 비트 이동과 뺄셈으로 곱셈을 대체할 수 있어서 성능을 향상시킬 수 있다는 것이다. 즉 31*i는 (i<<5)-i와 같다. 근래의 자바VM들은 이런 부류의 최적화를 자동적으로 수행한다.

### 3.3 한 줄짜리 hashCode

```java
@Override
public int hashCode() {
    return Objects.hash(lineNum, prefix, areaCode);
}
```

Objects 클래스의 해시코드를 계산해주는 hash 메소드를 이용한 것이다.

하지만 아쉽게도 속도는 느리다. 성능에 민감하지 않은 상황에서만 사용하자.

# 4. 주의점

### 4.1 hashCode의 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.

속도야 빨라지겠지만, 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수도 있다.

### 4.2 hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자.

그래야 클라이언트가 이 값에 의지하지 않게 되고, 추후에 계산 방식을 바꿀 수도 있다.

자세한 규칙을 공표하지 않는다면 해시 기능에서 결함을 발견했거나 더 나은 해시 방식을 알아낸 경우 다음 릴리스에서 수정할 수 있다.
