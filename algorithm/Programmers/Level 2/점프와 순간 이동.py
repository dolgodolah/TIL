# 처음 풀었을 때랑 똑같은 풀이과정을 겪었는데 느낌이 다르다.
# bfs로 풀다가 '음 당연히 안되겟지..', 다음에 자연스럽게 다른 알고리즘을 찾게 된다.
# *2로 점프하는게 무조건 이득이기 때문에 2로 나누어 떨어지는 곳에서는 무조건 점프한다고 보면 된다.
# 21년 5월 11일 두번째 풀이
def solution(n):
    answer=0
    while n>0:
        if n%2==0:
            n//=2
        else:
            answer+=1
            n//=2
    return answer

print(solution(5000))

# 21년 1월 27일 첫번째 풀이
#bfs로 풀다가 시간초과+런타임에러, dp로 풀다가 시간은 줄어들었으나 여전히 시간초과+런타임에러
#아니 뭐지?? 하고 다른사람 풀이 봤는데 살짝 그리디+수학문제다.
#일단 순간 이동하는게 건전지 사용량이 없기 때문에 무조건 좋다.
#해당 칸(n)이 2로 나누어떨어지는 칸이면 n//2칸에서 순간 이동한 것이다. 순간이동이므로 배터리 사용량은 0
#그런데 해당 칸이 7같은 홀수라면?
#3에서 순간 이동하고 +1을 할때가 가장 좋다.
#즉 배터리 사용량은 n%2가 된다.

def solution(n):
    answer = 0
    while n>0:
        answer+=n%2
        n//=2
    return answer

    # DP풀이 -> 시간초과+런타임에러(N의 범위가 10억까지라서 리스트 최대범위가 넘어가 에러가 뜨는거 같다.)
    # dp = [0]*(n+1)
    # dp[0]=0
    # for i in range(1,n+1):
    #     if i%2==1:
    #         dp[i]=dp[i-1]+1
    #     else:
    #         dp[i]=min(dp[i-1]+1,dp[i//2])
    # return dp[n]


print(solution(5))
# print(solution(5000))