# 0. Overview

이펙티브 자바 **아이템19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라**를 보고 공부한 내용을 정리했다.

상속용 클래스를 설계하기란 만만치 않다.

클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 그 문서는 반드시 지켜져야 한다.

다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메소드를 protected로 제공해야 할 수도 있다.

그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다.

상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.

# 1. 상속을 고려한 설계와 문서화

## 1.1 내부 구현 방식을 문서화 하자

메소드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다.

달리 말하면, **상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.**

클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

## 1.2 protected 메소드

내부 메커니즘을 문서로 남기는 것만이 상속을 위한 설계의 전부는 아니다.

효율적인 하위 클래스를 쉽게 만들 수 있게 하려면 protected 메소드 형태로 공개해야 할 수도 있다.

그렇다면 상속용 클래스를 설계할 때 어떤 메소드를 protected로 노출해야 할까?

안타깝게도 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어보는 것이 최선이다.

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.

꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스 작성할 때 빈자리가 확연히 드러나고,

하위 클래스를 여러 개 만들 때 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다.

protected 메소드 하나하나가 내부 구현에 해당하므로 구 수는 가능한 적어야 한다.


# 2. 상속 클래스의 주의점

널리 쓰일 클래스를 상속용으로 설계한다면 여러분이 문서화한 내부 사용 패턴과, protected 메소드와 필드를 구현하면서 선택한 결정에 영원히 책임져야 함을 잘 인식해야 한다.

그러니 **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증**해야 한다.

또한 **상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메소드를 호출해서는 안된다.**

상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메소드가 하위 클래스의 생성자보다 먼저 호출된다.

이는 프로그램을 오동작하게 만들 수 있다.

```java
public class Super {
    // 잘못된 코드 - 생성자가 재정의 가능 메소드를 호출하고 있다.
    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}
```

```java
public final class Sub extends Super {
    private final Instant instant;

    Sub() {
        instant = Intant.now();
    }

    @Override
    public void overrideMe() {
        Sysmtem.out.println(intant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```

instant를 두 번 출력하기를 기대한 프로그램이지만, 첫 번째는 null을 출력한다.

상위 클래스의 생성자는 하위 클래스의 생성자가 인스턴스 필드를 초기화하기도 전에 overrideMe를 호출하기 때문이다.

println이 null 입력을 받아들여서 그렇지 `NullPointerException`을 던지게 될 수도 있다.

clone과 readObject 메소드는 생성자와 비슷한 효과를 낸다. 즉, **clone과 readObject도 재정의 가능 메소드를 호출해서는 안된다.**

마지막으로, **Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 갖는다면 이 메소드들은 private이 아닌 protected로 선언해야 한다.**

# 3. 상속 금지

클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에서 생기는 제약도 상당하다는 것을 알았다.

추상 클래스나 인터페이스의 구현처럼 상속을 허용하는게 명백히 정당환 상황이 있지만, 그 외의 일반적인 구체 클래스는 어떻게 해야할까?

가장 좋은 방법은 상속용으로 설계하지 않은 클래스는 상속을 금지하는 것이다.

상속을 금지하는 방법은 두 가지다.

클래스를 **final로 선언하는 방법**과 **모든 생성자를 privated으로 선언하고 public 정적 팩토리를 만들어주는 방법**이다.