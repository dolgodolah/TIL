# 0. Overview

이펙티브 자바 **아이템71. 필요 없는 검사 예외 사용은 피하라**를 보고 공부한 내용을 정리했다.

꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 사용하기 고통스러운 API를 낳는다.

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.

복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.

옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

# 1. 검사 예외의 단점

검사 예외를 던지는 메소드를 호출하는 코드에서는 catch 블록을 두어 그 예외를 처리하거나, 더 바깥으로 던져 전파해야 한다. 어느 쪽이든 API 사용자에게 부담을 준다.

메소드가 단 하나의 검사 예외만 던질 때는 그 부담이 더 크다. 이미 검사 예외를 던지는 상황에서는 catch 문 하나 추가하는게 끝인데,

단 하나의 검사 예외라면 오직 그 예외 때문에 try 블록을 추가해야 한다.

더구나 검사 예외를 던지는 메소드는 스트림 안에서 직접 사용할 수 없다.

```java
try {
    obj.action(args);
} catch (TheCheckedException e) {
    throw new AssertionError(); // 일어날 수 없음
}
```

위 코드는 `TheCheckedException`이 발생할 수 없는 상황임에도 불구하고 `action` 메소드에서 검사 예외를 던지기 때문에 catch 문을 추가하게 됐다.

검사 예외의 단점을 감수하기에는 절대 최선의 방법이 아니다.

# 2. 해결 방법

검사 예외를 던지지 않는 방법을 고민해봐야 한다.

가장 쉬운 방법은 적절한 결과 타입을 담은 옵셔널을 반환하는 것이다.

이 방식의 단점이라면 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.

반면, 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메소드들을 활용해 부가 정보를 제공할 수 있다.

<br>

또 다른 방법으로, 검사 예외를 던지는 메소드를 2개로 쪼개 비검사 예외로 바꿀 수 있다.

```java
// 리팩토링 전
try {
    obj.action(args);
} catch (TheCheckedException e) {
    ... // 예외 상황에 대처
}

// 리팩토링 후
if (obj.actionPermitted(args)) {
    obj.action(Args);
} else {
    ... // 예외 상황에 대처
}
```

이 리팩토링을 모든 상황에 적용할 수는 없다. 적용할 수만 있다면 더 쓰기 편한 API를 제공할 수 있다.

그러나 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나, 외부 요인에 의해 상태가 변할 수 있다면 이 리팩토링은 적절하지 않다.

`actionPermitted`와 `action` 호출 사이에 객체의 상태가 변할 수 있기 때문이다.

# 3. 검사 예외(Checked Exception)를 사용해야 할 경우

그렇다면 검사 예외를 사용해야할 때는 언제일까?

검사 예외는 발생한 문제를 프로그래머가 처리하여 안전성을 높이게끔 해준다. (물론 과하게 사용하면 위에서 설명했듯 오히려 쓰기 불편한 API가 된다.)

`API를 제대로 사용해도 발생할 수 있는 예외`이거나, 프로그래머가 `의미 있는 조치를 취할 수 있는 경우`라면 검사 예외의 단점들을 받아들이고 사용해도 좋다.
