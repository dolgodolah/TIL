# Components와 Props

컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 살펴볼 수 있다.

## 컴포넌트 정의

컴포넌트의 기능은 단순한 템플릿 이상이다. 데이터가 주어졌을 때 이에 맞게 UI를 만들어 주는 것은 물론이고,

라이프사이클 API를 이용하여 컴포넌트가 화면에서 나타날 때, 사라질 때, 변화가 일어날 때 주어진 작업들을 처리할 수 있다.

임의 메소드를 만들어 특별한 기능도 붙여 줄 수도 있다.

### 함수 컴포넌트

컴포넌트를 정의하는 가장 간단한 방법은 JavaScript 함수를 작성하는 것이다.

```javascript
function Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
}
```

함수형 컴포넌트의 주요 단점은 state와 라이프사이클 API의 사용이 불가능 하다는 것인데 Hooks라는 기능이 도입되면서 해결되었다.

리액트 공식 매뉴얼에서는 컴포넌트를 새로 작성할 때 함수형 컴포넌트와 Hooks 사용을 권장하고 있다.

### 클래스 컴포넌트

또한 ES6의 class를 사용해 컴포넌트를 정의할 수 있다.

함수 컴포넌트와 역할은 똑같지만 클래스 컴포넌트의 경우 state 기능 및 라이프사이클 기능을 사용할 수 있고 임의 메소드를 정의할 수 있다.

```javascript
class Welcome extends React.Component {
    render() {
        return <h1>Hello, {this.props.name}</h1>;
    }
}
```

## 컴포넌트 렌더링

사용자가 정의한 컴포넌트로도 엘리먼트를 나타낼 수 있다.

```js
function  Welcome(props) {
    return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />
ReactDom.render(
    element,
    document.getElementById('root')
)
```

1. `<Welcome name="Sara" />` 엘리먼트로 `ReactDOM.render()`를 호출합니다.
2. React는 `{name: 'Sara'}`를 `props`로 하여 Welcome 컴포넌트를 호출합니다.
3. Welcome 컴포넌트는 결과적으로 `<h1>Hello, Sara</h1>` 엘리먼트를 반환합니다.
4. React DOM은 `<h1>Hello, Sara</h1>` 엘리먼트와 일치하도록 DOM을 효율적으로 업데이트합니다.

## 컴포넌트 합성

컴포넌트는 자신의 출력에 다른 컴포넌트를 참조할 수 있다.

버튼, 폼, 다이얼로그, 화면 등의 모든 것들이 흔히 컴포넌트들로 표현된다.

아래 예는 `Welcome` 컴포넌트를 여러 번 렌더링하는 `App` 컴포넌트이다.

```js
function Welcome(props) {
    return <h1>Hello, {props.name}!</h1>;
}

function App() {
    return (
        <div>
            <Welcome name="Sara" />
            <Welcome name="Cahal" />
            <Welcome name="Edite" />
        </div>
    );
}

ReactDOM.render(
    <App />,
    document.getElementById('root')
);
```

Button과 같은 작은 컴포넌트부터 시작해서 뷰 계층의 상단으로 올라가면서 점진적으로 작업할 수 있다.

## 감싸인 요소

컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 한다.

```js
// 오류 발생
function App() {
    return (
        <h1>Hello</h1>
        <h2>World</h2>
    );
}

// 정상 동작
function App() {
    return (
        <div>
            <h1>Hello</h1>
            <h2>World</h2>
        </div>
    );
}
```

React의 Virtual DOM에서 컴포넌트 변화를 감지하기 위해 효율적으로 비교할 수 있도록

컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문이다.

## props는 읽기 전용

함수 컴포넌트나 클래스 컴포넌트 모두 컴포넌트의 자체 props를 수정해서는 안된다.

```js
function sum(a, b) {
    return a + b;
}
```

이런 함수들은 입력값을 바꾸려 하지 않고 항상 동일한 입력값에 대해 동일한 결과를 반환한다.

모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 이처럼 동작해야 한다.

## defaultProps로 props 기본값 설정

```js
// MyComponent.js
const MyComponent = props => {
    return <div>안녕하세요, 제 이름은 {props.name}입니다.</div>;
};

MyComponent.defaultProps = {
    name: '홍길동'
};
```

props 값을 지정하지 않았을 때 defaultProps에 설정한 값이 지정된다.

## 태그 사이 내용을 보여주는 children

```js
const App = () => {
    return <MyComponent>리액트</MyComponent>
}
```

`MyComponent` 태그 사이에 작성한 '리액트'라는 문자열을 보여주려면 props.children 값을 보여 주어야 한다.

```js
const MyComponent = props => {
    return <div>children 값은 {props.children}입니다.</div>
}
```

## 비구조화 할당 문법을 통해 props 값 추출

`props.name`, `props.children`과 같이 props. 키워드를 붙여주고 있는데

ES6의 비구조화 할당 문법을 통해 내부값을 바로 추출하는 방법이다.

```js
const MyComponent = props => {
    const {name, children} = props; // 비구조화 할당
    return (
        <div>
            안녕하세요, 제 이름은 {name}입니다. <br />
            children 값은 {children}입니다.
        </div>
    );
};
```

함수의 파라미터 부분에서도 비구조화 할당을 사용할 수 있다.

```js
const MyComponent = ({name, children}) => {
    return (
        <div>
            안녕하세요, 제 이름은 {name}입니다. <br />
            children 값은 {children}입니다.
        </div>
    );
};
```
